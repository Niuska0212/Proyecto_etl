import dash
from dash import dcc, html, dash_table, Input, Output, State, callback
import dash_bootstrap_components as dbc
import pandas as pd
import plotly.express as px
import base64
import io
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder, MinMaxScaler
import joblib
import plotly.graph_objects as go
from sklearn.metrics import (accuracy_score, classification_report, 
                            confusion_matrix, precision_score, 
                            recall_score, f1_score, roc_auc_score)

# Inicializar la aplicación Dash
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])
app.title = "Sistema ETL para Reservas Hoteleras"

# ============ Funciones de procesamiento (las que proporcionaste) ============
# (Aquí irían todas las funciones que proporcionaste: load_csv, load_excel, load_json,
# clean_data, transform_data, exploratory_analysis, train_random_forest, etc.)
# Para mantener el código compacto, no las repetiré pero deben estar incluidas

# ============ Diseño de la aplicación ============
app.layout = dbc.Container([
    html.H1("Sistema ETL para Reservas Hoteleras", className="mb-4 text-center"),
    dbc.Tabs([
        # Pestaña 1: Carga de datos
        dbc.Tab([
            html.Div([
                dcc.Upload(
                    id='upload-data',
                    children=html.Div([
                        'Arrastra y suelta o ',
                        html.A('Selecciona un archivo')
                    ]),
                    style={
                        'width': '100%',
                        'height': '60px',
                        'lineHeight': '60px',
                        'borderWidth': '1px',
                        'borderStyle': 'dashed',
                        'borderRadius': '5px',
                        'textAlign': 'center',
                        'margin': '10px'
                    },
                    multiple=False
                ),
                html.Div(id='output-data-upload'),
                html.Div(id='data-preview-container')
            ], className='mt-4')
        ], label="Carga de Datos"),
        
        # Pestaña 2: ETL
        dbc.Tab([
            html.Div([
                dbc.Row([
                    dbc.Col([
                        html.H4("Datos Originales"),
                        html.Div(id='original-data-table')
                    ], width=6),
                    dbc.Col([
                        html.H4("Datos Transformados"),
                        html.Div(id='transformed-data-table')
                    ], width=6)
                ]),
                dbc.Row([
                    dbc.Col([
                        html.H5("Filtros"),
                        dcc.Dropdown(
                            id='column-filter',
                            options=[],
                            multi=True,
                            placeholder="Selecciona columnas para filtrar"
                        ),
                        html.Div(id='filter-controls')
                    ], width=12)
                ]),
                dbc.Button("Aplicar Transformación", id='transform-button', className="mt-3")
            ], className='mt-4')
        ], label="ETL"),
        
        # Pestaña 3: Minería de Datos
        dbc.Tab([
            html.Div([
                dbc.Row([
                    dbc.Col([
                        html.H4("Análisis Exploratorio"),
                        dcc.Dropdown(
                            id='eda-plot-type',
                            options=[
                                {'label': 'Distribución de Hoteles', 'value': 'hotel_dist'},
                                {'label': 'Distribución de ADR', 'value': 'adr_dist'},
                                {'label': 'Países de Origen', 'value': 'country'},
                                {'label': 'Cancelaciones vs Lead Time', 'value': 'cancel_lead'}
                            ],
                            value='hotel_dist'
                        ),
                        dcc.Graph(id='eda-plot')
                    ], width=6),
                    dbc.Col([
                        html.H4("Resultados del Modelo"),
                        html.Div(id='model-metrics'),
                        dcc.Graph(id='confusion-matrix')
                    ], width=6)
                ]),
                dbc.Button("Entrenar Modelo", id='train-model-button', className="mt-3")
            ], className='mt-4')
        ], label="Minería de Datos"),
        
        # Pestaña 4: Toma de Decisiones
        dbc.Tab([
            html.Div([
                dbc.Row([
                    dbc.Col([
                        html.H4("Indicadores Clave"),
                        html.Div(id='kpi-cards')
                    ], width=12)
                ]),
                dbc.Row([
                    dbc.Col([
                        html.H4("Análisis para Toma de Decisiones"),
                        dcc.Dropdown(
                            id='decision-plot-type',
                            options=[
                                {'label': 'Cancelaciones por Temporada', 'value': 'season'},
                                {'label': 'Impacto de ADR en Cancelaciones', 'value': 'adr_impact'},
                                {'label': 'Efectividad de Depósitos', 'value': 'deposit'}
                            ],
                            value='season'
                        ),
                        dcc.Graph(id='decision-plot')
                    ], width=12)
                ]),
                dbc.Row([
                    dbc.Col([
                        html.H4("Recomendaciones"),
                        html.Div(id='recommendations')
                    ], width=12)
                ])
            ], className='mt-4')
        ], label="Toma de Decisión")
    ])
], fluid=True)

# ============ Callbacks ============

# Callback para cargar y previsualizar datos
@app.callback(
    [Output('output-data-upload', 'children'),
     Output('data-preview-container', 'children'),
     Output('original-data-table', 'children')],
    [Input('upload-data', 'contents')],
    [State('upload-data', 'filename')]
)
def update_output(contents, filename):
    if contents is None:
        return [html.Div("No se ha cargado ningún archivo."), None, None]
    
    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    
    try:
        if 'csv' in filename:
            df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))
        elif 'xls' in filename:
            df = pd.read_excel(io.BytesIO(decoded))
        elif 'json' in filename:
            df = pd.read_json(io.StringIO(decoded.decode('utf-8')))
        else:
            return [html.Div("Formato de archivo no soportado"), None, None]
    except Exception as e:
        return [html.Div(f"Error al cargar el archivo: {str(e)}"), None, None]
    
    # Guardar el dataframe original para usar en otras pestañas
    global original_df
    original_df = df.copy()
    
    # Mostrar información básica del archivo
    file_info = html.Div([
        html.H5(filename),
        html.Hr(),
        html.P(f"Filas: {df.shape[0]}"),
        html.P(f"Columnas: {df.shape[1]}"),
        html.P("Primeras filas:")
    ])
    
    # Mostrar una tabla con las primeras filas
    preview_table = dash_table.DataTable(
        data=df.head().to_dict('records'),
        columns=[{'name': i, 'id': i} for i in df.columns],
        page_size=5
    )
    
    # Crear tabla para la pestaña ETL
    original_table = dash_table.DataTable(
        data=df.head(10).to_dict('records'),
        columns=[{'name': i, 'id': i} for i in df.columns],
        page_size=10,
        style_table={'overflowX': 'auto'}
    )
    
    return [file_info, preview_table, original_table]

# Callback para actualizar filtros en pestaña ETL
@app.callback(
    [Output('column-filter', 'options'),
     Output('filter-controls', 'children')],
    [Input('original-data-table', 'children')]
)
def update_filters(_):
    if 'original_df' not in globals():
        return [], None
    
    df = original_df
    options = [{'label': col, 'value': col} for col in df.columns]
    
    # Aquí podríamos agregar controles específicos para cada columna seleccionada
    controls = html.Div([
        html.P("Selecciona columnas para ver controles de filtrado específicos.")
    ])
    
    return [options, controls]

# Callback para transformar datos
@app.callback(
    Output('transformed-data-table', 'children'),
    [Input('transform-button', 'n_clicks')]
)
def transform_data_callback(n_clicks):
    if n_clicks is None or 'original_df' not in globals():
        return None
    
    df = original_df.copy()
    df_cleaned = clean_data(df)
    df_transformed = transform_data(df_cleaned)
    
    global transformed_df
    transformed_df = df_transformed.copy()
    
    table = dash_table.DataTable(
        data=df_transformed.head(10).to_dict('records'),
        columns=[{'name': i, 'id': i} for i in df_transformed.columns],
        page_size=10,
        style_table={'overflowX': 'auto'}
    )
    
    return table

# Callback para gráficos EDA
@app.callback(
    Output('eda-plot', 'figure'),
    [Input('eda-plot-type', 'value')]
)
def update_eda_plot(plot_type):
    if 'transformed_df' not in globals():
        return px.scatter(title="Carga y transforma los datos primero")
    
    df = transformed_df
    
    if plot_type == 'hotel_dist':
        fig = px.bar(df['hotel'].value_counts(), 
                    title='Distribución de Tipos de Hotel')
    elif plot_type == 'adr_dist':
        fig = px.histogram(df, x='adr', 
                          title='Distribución de ADR (Tarifa Diaria Promedio)')
    elif plot_type == 'country':
        top_countries = df['country'].value_counts().head(15)
        fig = px.bar(top_countries, 
                    title='Top 15 Países de Origen de los Clientes')
    elif plot_type == 'cancel_lead':
        fig = px.box(df, x='is_canceled', y='lead_time',
                    title='Relación entre Lead Time y Cancelaciones')
    
    return fig

# Callback para entrenar modelo y mostrar resultados
@app.callback(
    [Output('model-metrics', 'children'),
     Output('confusion-matrix', 'figure')],
    [Input('train-model-button', 'n_clicks')]
)
def train_and_evaluate_model(n_clicks):
    if n_clicks is None or 'transformed_df' not in globals():
        return [html.Div("Presiona el botón para entrenar el modelo."), go.Figure()]
    
    df = transformed_df.copy()
    
    # Preparar datos para el modelo
    try:
        X = df.drop(columns=['is_canceled'])
        y = df['is_canceled']
        
        # Codificar variables categóricas
        categorical_cols = X.select_dtypes(include=['object']).columns
        for col in categorical_cols:
            X[col] = LabelEncoder().fit_transform(X[col])
        
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)
        
        # Entrenar modelo
        model = RandomForestClassifier(n_estimators=100, random_state=42)
        model.fit(X_train, y_train)
        
        # Evaluar modelo
        y_pred = model.predict(X_test)
        y_proba = model.predict_proba(X_test)[:, 1]
        
        # Calcular métricas
        accuracy = accuracy_score(y_test, y_pred)
        precision = precision_score(y_test, y_pred)
        recall = recall_score(y_test, y_pred)
        f1 = f1_score(y_test, y_pred)
        roc_auc = roc_auc_score(y_test, y_proba)
        
        # Crear matriz de confusión
        cm = confusion_matrix(y_test, y_pred)
        fig = px.imshow(cm,
                       labels=dict(x="Predicho", y="Real", color="Cantidad"),
                       x=['No Cancelado', 'Cancelado'],
                       y=['No Cancelado', 'Cancelado'],
                       title="Matriz de Confusión")
        fig.update_layout(width=400, height=400)
        
        # Mostrar métricas
        metrics_html = html.Div([
            html.H5("Métricas del Modelo:"),
            html.Ul([
                html.Li(f"Exactitud: {accuracy:.2f}"),
                html.Li(f"Precisión: {precision:.2f}"),
                html.Li(f"Sensibilidad: {recall:.2f}"),
                html.Li(f"F1-Score: {f1:.2f}"),
                html.Li(f"ROC-AUC: {roc_auc:.2f}")
            ])
        ])
        
        return [metrics_html, fig]
    
    except Exception as e:
        return [html.Div(f"Error al entrenar el modelo: {str(e)}"), go.Figure()]

# Callback para gráficos de toma de decisiones
@app.callback(
    [Output('decision-plot', 'figure'),
     Output('kpi-cards', 'children'),
     Output('recommendations', 'children')],
    [Input('decision-plot-type', 'value')]
)
def update_decision_components(plot_type):
    if 'transformed_df' not in globals():
        return [px.scatter(title="Carga y transforma los datos primero"), None, None]
    
    df = transformed_df
    
    # KPIs
    cancelation_rate = df['is_canceled'].mean() * 100
    avg_adr = df['adr'].mean()
    avg_lead_time = df['lead_time'].mean()
    
    kpi_cards = dbc.Row([
        dbc.Col(dbc.Card([
            dbc.CardHeader("Tasa de Cancelación"),
            dbc.CardBody(f"{cancelation_rate:.1f}%")
        ], color="danger", inverse=True), width=4),
        dbc.Col(dbc.Card([
            dbc.CardHeader("ADR Promedio"),
            dbc.CardBody(f"${avg_adr:.2f}")
        ], color="info", inverse=True), width=4),
        dbc.Col(dbc.Card([
            dbc.CardHeader("Lead Time Promedio"),
            dbc.CardBody(f"{avg_lead_time:.1f} días")
        ], color="warning", inverse=True), width=4)
    ], className="mb-4")
    
    # Gráficos
    if plot_type == 'season':
        # Agrupar por mes para ver estacionalidad
        df['arrival_month'] = pd.to_datetime(df['arrival_date']).dt.month
        monthly_cancel = df.groupby('arrival_month')['is_canceled'].mean().reset_index()
        fig = px.line(monthly_cancel, x='arrival_month', y='is_canceled',
                     title="Tasa de Cancelación por Mes")
        fig.update_yaxes(tickformat=".0%")
        
    elif plot_type == 'adr_impact':
        fig = px.box(df, x='is_canceled', y='adr',
                    title="Distribución de ADR por Estado de Reserva")
        
    elif plot_type == 'deposit':
        deposit_cancel = df.groupby('deposit_type')['is_canceled'].mean().reset_index()
        fig = px.bar(deposit_cancel, x='deposit_type', y='is_canceled',
                    title="Tasa de Cancelación por Tipo de Depósito")
        fig.update_yaxes(tickformat=".0%")
    
    # Recomendaciones basadas en análisis
    recommendations = html.Div([
        html.H5("Recomendaciones:"),
        html.Ul([
            html.Li("Ofrecer descuentos o beneficios para reservas con alto lead time para reducir cancelaciones"),
            html.Li("Revisar política de depósitos, ya que ciertos tipos tienen mayor tasa de cancelación"),
            html.Li("Ajustar precios (ADR) en temporadas con alta cancelación")
        ])
    ])
    
    return [fig, kpi_cards, recommendations]

# Ejecutar la aplicación
if __name__ == '__main__':
    app.run_server(debug=True)